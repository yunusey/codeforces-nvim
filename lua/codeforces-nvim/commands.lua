local codeforces = require("codeforces-nvim.codeforces")
local utils = require("codeforces-nvim.utils")

local M = {}

--- @param problem string
--- @return string[]
--- Returns the command to compile the given `problem`
local get_compile_command = function(problem)
    local executable = codeforces.get_solution_file(problem, nil)
    local command = codeforces.options.compiler[codeforces.options.extension]
    local new_command = {}

    for _, i in ipairs(command) do
        local modified = string.gsub(i, "@", executable)
        table.insert(new_command, modified)
    end

    return new_command
end

--- @param problem string
--- @return string[]
--- Returns the command to run the given `problem`
local get_run_command = function(problem)
    local executable = codeforces.get_solution_file(problem, nil)
    local command = codeforces.options.run[codeforces.options.extension]
    local new_command = {}

    for _, i in ipairs(command) do
        local modified = string.gsub(i, "@", executable)
        table.insert(new_command, modified)
    end
    return new_command
end

--- @param problem string
--- @return string
--- @see get_run_command
--- Returns the command to run the given `problem`. Unlike `get_run_command`,
--- this one returns a concatenated `string` since it runs directly in terminal
local get_terminal_run_command = function(problem)
    local executable = codeforces.get_solution_file(problem, nil)
    local command = codeforces.options.run[codeforces.options.extension]
    local new_command = table.concat(command, " "):gsub("@", executable)
    return new_command
end

--- @param compiler string[]
--- @see get_compile_command
--- Using the compile command generated by `get_compile_command`, compile the given `problem`
--- and call the `exit_function` once done
M.compile = function(compiler, exit_function)
    if compiler == nil or compiler == {} then return end

    local errors = false
    local all_data = {}

    vim.fn.jobstart(compiler, {
        on_stderr = function(_, data)
            if utils.check_data(data) == false then return end
            errors = true
            for _, i in pairs(data) do
                table.insert(all_data, i)
            end
        end,
        on_exit = function(_, _)
            if errors then
                codeforces.options.notify("Compilation Failed ✗", table.concat(all_data, "\n"), "error")
            else
                codeforces.options.notify("Compilation Succeeded ✓", nil, "success")
                exit_function()
            end
        end,
    })
end

--- @param errors table<string, string[], string[]>[]
--- This function aims to open a `diffview` window in Neovim that shows
--- the differences between the `user_output` and `output`
M.handle_differences = function(errors)
    local user_output_content = {}
    local expected_output_content = {}
    for _, i in pairs(errors) do
        local test_case = i[1]
        table.insert(user_output_content, "Test Case: " .. test_case)
        table.insert(expected_output_content, "Test Case: " .. test_case)

        local user_output = i[2]
        local expected_output = i[3]
        for _, j in pairs(user_output) do
            table.insert(user_output_content, j)
        end
        for _, j in pairs(expected_output) do
            table.insert(expected_output_content, j)
        end
    end
    local user_output_file = vim.fn.tempname()
    local expected_output_file = vim.fn.tempname()
    vim.fn.writefile(user_output_content, user_output_file)
    vim.fn.writefile(expected_output_content, expected_output_file)

    vim.cmd(":tabnew " .. user_output_file)
    vim.cmd(":vert diffsplit " .. expected_output_file)
end

--- @param problem string
--- Using the run command generated by `get_run_command`, run the given `problem`
--- for each test case and check if the answer is correct
M.test_problem = function(problem)
    local compiler = get_compile_command(problem)
    local run = function()
        local test_path = vim.fs.joinpath(codeforces.paths.tests, codeforces.get_current_contest(), problem)
        local errors = {}
        for test_case in vim.fs.dir(test_path) do
            -- we don't want to go through the same test case twice.
            if test_case:match("%.out$") then goto continue end

            test_case = utils.trim_extension(test_case)
            local output_path = codeforces.get_test_file(problem, test_case, ".out")
            local input_path = codeforces.get_test_file(problem, test_case, ".in")

            local run_command = get_run_command(problem)
            local output = vim.system(run_command, {
                stdin = vim.fn.readfile(input_path),
                timeout = codeforces.timeout, -- 15 seconds
            }):wait()

            local user_output = vim.fn.split(output.stdout, "\n")
            local expected_output = vim.fn.readfile(output_path)

            local same = utils.compare(user_output, expected_output)
            local message = ""
            local type = nil
            if same == true then
                message = "Test Case #" .. test_case .. " success ✓"
                type = "success"
            else
                table.insert(errors, { test_case, user_output, expected_output })
                message = "Test Case #" .. test_case .. " failed x"
                type = "error"
            end

            codeforces.options.notify(message, nil, type)

            ::continue::
        end

        if not vim.tbl_isempty(errors) then
            M.handle_differences(errors)
        else
            codeforces.options.notify("All tests passed!", nil, "success")
        end
    end

    if utils.check_data(compiler) then
        M.compile(compiler, run)
    else
        run()
    end
end

--- @param problem string
--- @see get_terminal_run_command
--- Using the run command generated by `get_terminal_run_command`, run the given `problem` in a terminal
M.run_normally = function(problem)
    local compiler = get_compile_command(problem)
    local run = function()
        local run_command = get_terminal_run_command(problem)
        local cmd = string.format(':TermExec cmd="%s"', run_command)
        if codeforces.options.use_term_toggle == true then
            vim.cmd(cmd)
        else
            vim.cmd(":terminal ")
            vim.cmd(":set number!")
            vim.cmd(":set relativenumber!")
            vim.api.nvim_paste(run_command, true, 3)
        end
    end

    if utils.check_data(compiler) then
        M.compile(compiler, run)
    else
        run()
    end
end

--- @param problem string
--- Opens up a new buffer for the user to write a custom test case
M.create_custom_test_case = function(problem)
    local buffer = vim.api.nvim_create_buf(true, true)
    vim.api.nvim_buf_set_name(buffer, "Your Test Case For Problem #" .. problem)

    local x, y =
        math.ceil(vim.api.nvim_win_get_height(0) / 2 - 10), math.ceil(vim.api.nvim_win_get_width(0) / 2 - 50)
    local win = vim.api.nvim_open_win(
        buffer,
        true,
        { relative = "editor", width = 100, height = 20, row = x, col = y, anchor = "NW", border = "rounded" }
    )

    vim.api.nvim_buf_set_keymap(buffer, "n", "<CR>", "", {
        callback = function()
            M.save_custom_test(problem, buffer, win)
            M.run_custom_test(problem)
        end,
    })
end

--- @param problem string
--- @param buf number
--- @param win number
--- Saves the custom test case written by the user
M.save_custom_test = function(problem, buf, win)
    local input = vim.api.nvim_buf_get_lines(buf, 0, -1, false)
    local file_path = vim.fs.joinpath(
        codeforces.paths.solutions,
        codeforces.get_current_contest(),
        string.format("custom-%s.in", problem)
    )
    vim.fn.writefile(input, file_path)
    vim.api.nvim_win_close(win, true)
    vim.api.nvim_buf_delete(buf, { force = true })
end

--- @param problem string
--- @see get_run_command
--- Using the run command generated by `get_run_command`, run the given `problem` with the generated
--- custom test case
M.run_custom_test = function(problem)
    local file_path = vim.fs.joinpath(
        codeforces.paths.solutions,
        codeforces.get_current_contest(),
        string.format("custom-%s.in", problem)
    )
    local command = string.format('"%s < %s"', table.concat(get_run_command(problem)), file_path)
    if codeforces.options.use_term_toggle == true then
        vim.cmd(":TermExec cmd=" .. command)
    else
        vim.cmd(":terminal ")
        vim.cmd(":set number!")
        vim.cmd(":set relativenumber!")
        vim.api.nvim_paste(command, true, 3)
    end
end

return M
